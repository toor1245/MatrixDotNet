<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Summation Kahan and Klein overview. | MatrixDotNet </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Summation Kahan and Klein overview. | MatrixDotNet ">
    <meta name="generator" content="docfx 2.56.5.0">
    
    <link rel="shortcut icon" href="../../images/logo/matrix.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    <meta property="docfx:rel" content="../../">
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../images/logo/matrix.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list">Search Results for <span></span></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination" data-first="First" data-prev="Previous" data-next="Next" data-last="Last"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="summation-kahan-and-klein-overview">Summation Kahan and Klein overview.</h1>

<p>The float and double types follow the IEEE 754 standard, which states that a
floating-point number is represented by a sign S, an exponent E, and a mantissa M which
can be converted to the real value by the following rule:</p>
<p>V = (-1)<sup> S </sup> * 1.M * 2<sup>E - E<sub>bias</sub></sup></p>
<p>Computer can’t represent every real number in memory: the range
and the precision depends on the number of bits that we have. In table you can see
the main characteristics of the 32-bit, 64-bit, and 80-bit floating-point numbers.</p>
<table>
<thead>
<tr>
<th></th>
<th>Sign</th>
<th>Exponent</th>
<th>Mantissa</th>
<th>Digits</th>
<th>E<sub>bias</sub></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>32bit</strong></td>
<td>1</td>
<td>8</td>
<td>23</td>
<td>≈7.2</td>
<td>127</td>
</tr>
<tr>
<td><strong>64bit</strong></td>
<td>1</td>
<td>11</td>
<td>52</td>
<td>≈15.9</td>
<td>1023</td>
</tr>
<tr>
<td><strong>81bit</strong></td>
<td>1</td>
<td>15</td>
<td>64</td>
<td>≈19.2</td>
<td>16383</td>
</tr>
</tbody>
</table>
<p>Most of the classic arithmetic rules don’t work with floating-point numbers. Here is
one of the most famous IEEE 754 equations:
0.1d + 0.2 ≠ 0.3d</p>
<p>We have such situations because 0.1d, 0.2d, and 0.3d can’t be perfectly presented in
IEEE 754 notation:</p>
<pre><code>0.1d ~ 0.100000000000000005551115123125783
</code></pre>
<p><code>+</code></p>
<pre><code>0.2d ~ 0.200000000000000011102230246251565
</code></pre>
<p><code>=</code></p>
<pre><code>0.300000000000000044408920985006262

0.3d ~ 0.299999999999999988897769753748435
</code></pre>
<p>Many arithmetic rules don’t work with float and double in general:</p>
<ul>
<li>(a + b) + c ≠ a + (b + c)</li>
<li>(a * b) * c ≠ a * (b * c)</li>
<li>(a + b) * c ≠ a * c + b * c</li>
<li>a<sup>x + y</sup> ≠ a<sup>x</sup> * a<sup>y</sup></li>
</ul>
<h5 id="lets-consider-the-following-sample">Lets consider the following sample:</h5>
<pre><code class="lang-csharp" name="AbsorptionSample.cs">using System;
using System.Text;
using MatrixDotNet;
using MatrixDotNet.Extensions;

namespace Samples.logs.AbsorptionSample
{
    public class AbsorptionSampleDocs
    {
        public static void Run()
        {

            // initialize Matrix.
            Matrix&lt;double&gt; matrix64Klein = new double[5, 5];
            Matrix&lt;double&gt; matrix64Kahan = new double[5, 5];
            Matrix&lt;decimal&gt; matrix128 = new decimal[5, 5];

            // assign max value for demonstration absorption.
            matrix64Kahan[0, 0] = Math.Pow(10,16);
            matrix64Klein[0, 0] = Math.Pow(10,16);
            matrix128[0, 0] = (decimal) Math.Pow(10,28);

            // make error
            for (int i = 0; i &lt; matrix64Klein.Rows; i++)
            {
                for (int j = 1; j &lt; matrix64Klein.Columns; j++)
                {
                    matrix64Kahan[i, j] = 1;
                    matrix64Klein[i, j] = 0.1;
                    matrix128[i, j] = 0.1m;
                }
            }

            // compare algorithms of summation first case
            double defaultSum0 = matrix64Kahan.Sum();
            double kahanSum0 = matrix64Kahan.GetKahanSum();
            double kleinSum0 = matrix64Kahan.GetKleinSum();

            // compare algorithms of summation second case
            double defaultSum1 = matrix64Klein.Sum();
            double kahanSum1 = matrix64Klein.GetKahanSum();
            double kleinSum1 = matrix64Klein.GetKleinSum();

            // compare algorithms of summation third case
            decimal defaultSum2 = matrix128.Sum();
            decimal kahanSum2 = matrix128.GetKahanSum();
            decimal kleinSum2 = matrix128.GetKleinSum();
        }
    }
}

</code></pre>
<p>As you can see we have three matrix with 64 and 128 bit, so next step assign max values for this matrices for demonstration hit in absorption.
For invoke Klein's or Kahan's algorithm must invoke method <code>GetKahanSum()</code> and <code>GetKleinSum()</code><br>
Klein's algorithm have the most accuracy summation of matrix than Kahan's, however if values not big you can use Kahan's algorithm.</p>
<h4 id="output">Output</h4>
<pre><code class="lang-csharp" name="AbsorptionSample.cs">        64 bit
Default sum: 10,000,000,000,000,000.00
Kahan sum:   10,000,000,000,000,020.00
Klein sum:   10,000,000,000,000,020.00

        64 bit
Default sum: 10,000,000,000,000,000.00
Kahan sum:   10,000,000,000,000,000.00
Klein sum:   10,000,000,000,000,002.00

        128 bit
Default sum: 10,000,000,000,000,000,000,000,000,000.00
Default sum: 10,000,000,000,000,000,000,000,000,000.00
Klein sum:   10,000,000,000,000,000,000,000,000,002.00

</code></pre>
<p>Thus, the default sum counts incorrectly, the runtime rounds it because the floating type precision is not enough to handle digit numbers.
Klein calculates with less error, but at the same time it works slower than Kahan.</p>
<div class="NOTE">
<h5>Note</h5>
<p>If you didn't find answer for your question on this page, <a href="https://gitter.im/MatrixDotNet/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge">ask it on gitter</a>.</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/toor1245/MatrixDotNet/blob/master/docs/articles/guides/absorption.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2020 MatrixDotNet
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
