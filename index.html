<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>





 | MatrixDotNet </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="





 | MatrixDotNet ">
    <meta name="generator" content="docfx 2.45.1.0">
    
    <link rel="shortcut icon" href="images/logo/matrix.ico">
    <link rel="stylesheet" href="styles/docfx.vendor.css">
    <link rel="stylesheet" href="styles/docfx.css">
    <link rel="stylesheet" href="styles/main.css">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <meta property="docfx:navrel" content="toc.html">
    <meta property="docfx:tocrel" content="toc.html">
    
    <meta property="docfx:rel" content="">
    
  </head>  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="index.html">
                <img id="logo" class="svg" src="images/logo/matrix.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div class="container body-content">
        
        <div id="search-results">
          <div class="search-list"></div>
          <div class="sr-items">
            <p><i class="glyphicon glyphicon-refresh index-loading"></i></p>
          </div>
          <ul id="pagination"></ul>
        </div>
      </div>
      <div role="main" class="container body-content hide-when-search">
        <div class="article row grid">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">

<p><img src="images/MatrixDotNet.png" alt=""></p>
<h3 align="center">
<p><a href="https://www.nuget.org/packages/MatrixDotNet/"><img src="https://img.shields.io/nuget/v/MatrixDotNet.svg" alt="NuGet"></a>
<a href="https://www.nuget.org/packages/MatrixDotNet/"><img src="https://img.shields.io/nuget/dt/matrixdotnet.svg" alt="Downloads"></a>
<a href="https://github.com/toor1245/MatrixDotNet/stargazers"><img src="https://img.shields.io/github/stars/toor1245/MatrixDotNet?color=brightgreen" alt="Stars"></a>
<a href="https://gitter.im/MatrixDotNet/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><img src="https://badges.gitter.im/MatrixDotNet/community.svg" alt="Gitter"></a>
<a href="https://www.nuget.org/packages/MatrixDotNet/"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License"></a></p>
</h3>
<h3 align="center">
  <a href="#Features">Features</a>
  <span> · </span>
  <a href="https://toor1245.github.io/MatrixDotNet/articles/intro.html">Getting started</a>
  <span> · </span>
  <a href="https://toor1245.github.io/MatrixDotNet/articles/guides/absorption.html">Documentation</a>
  <span> · </span>
  <a href="https://toor1245.github.io/MatrixDotNet/articles/features/getting_started.html">Optimization</a>
  <span> · </span>
  <a href="https://toor1245.github.io/MatrixDotNet/api/index.html">API Reference</a>
</h3> 
<p>MatrixDotNet is a powerful .NET library for calculate matrix. You can install MatrixDotNet via <a href="https://www.nuget.org/packages/MatrixDotNet/">NuGet package</a>.</p>
<h2 id="features">Features</h2>
<ul>
<li>Have many algorithms such sections as: factorizations, solving a linear system, conversion matrix, statistics</li>
<li>Have algorithms which enhance precision</li>
<li>You can write your matrix to markdown or html and open them with happen .dat file</li>
<li><a href="https://www.nuget.org/packages/MatrixDotNet.Extensions.Core/">MatrixDotNet.Extensions.Core</a> for .NET Core which intended for significant speed calculations on big size matrices, due to SIMD(AVX2,Sse2), unsafe and parallel programming.</li>
</ul>
<blockquote>
<p>See <a href="https://toor1245.github.io/MatrixDotNet/articles/features/getting_started.html">MatrixDotNet.Extensions.Core</a> documentation.</p>
</blockquote>
<h3 id="have-many-algorithms-such-sections-as-factorization-solver-conversion-matrix-statistics">Have many algorithms such sections as: factorization, solver, conversion matrix, statistics</h3>
<p>Lets consider several algorithms on each section.</p>
<ul>
<li><a href="#Factorizations">Factorizations</a></li>
<li><a href="#Solving a linear system">Solving a linear system</a></li>
<li><a href="#Conversion matrix">Conversion matrix</a></li>
<li><a href="#Statistics">Statistics</a></li>
</ul>
<h4 id="factorizations">Factorizations</h4>
<p>In many applications, it is useful to decompose a matrix using other representations.
All decompositions available in namespace <code>MatrixDotNet.Extensions.Decomposition</code>.
So lets consider decompositions which supported by MatrixDotNet.</p>
<h5 id="lup-decomposition">LUP decomposition</h5>
<p>The LU decomposition finds a representation for the square matrix A as:</p>
<h5> A = LU</h5>
<ul>
<li>where L is lower-triangular matrix <code>n x n</code></li>
<li>where U is upper-triangular matrix <code>n x n</code></li>
</ul>
<p>for example lets take matrix size <code>3 x 3</code></p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/d536704df4f1374607bef1519ce452a28ea4a03a" alt="example"></p>
<p>Without a proper ordering or permutations in the matrix, the factorization may fail to materialize. For example, it is easy to verify (by expanding the matrix multiplication) that a<sub>11</sub> = l<sub>11</sub> * u<sub>11</sub>
If a<sub>11</sub> = 0, then at least one of  l<sub>11</sub> and u<sub>11</sub>  has to be zero, which implies that either <code>L</code> or <code>U</code> is singular.  This is impossible if A is nonsingular (invertible). This is a procedural problem. It can be removed by simply reordering the rows of <code>A</code> so that the first element of the permuted matrix is nonzero.
The same problem in subsequent factorization steps can be removed the same way.</p>
<p>Lets see LU factorization in <code>MatrixDotNet</code></p>
<pre><code class="lang-c#">public class LUSample
{
    public static void Run()
    {
        // initialize matrix with random values.
        Matrix&lt;double&gt; matrix = BuildMatrix.Random(5, 5, -10, 10);
        
        // display matrix.
        matrix.Pretty();
        
        // LU decomposition.
        matrix.GetLowerUpper(out var lower,out var upper);
        
        // display lower-triangular matrix.
        Console.WriteLine(&quot;lower-triangular matrix&quot;);
        lower.Pretty();
        
        // display upper-triangular matrix.
        Console.WriteLine(&quot;upper-triangular matrix&quot;);
        upper.Pretty();
        
        // A = LU
        Console.WriteLine(&quot;A = LU&quot;);
        Console.WriteLine(lower * upper);
    }
}
</code></pre>
<h6 id="output">Output</h6>
<pre><code class="lang-ini">
Number of rows: 5
Number of columns: 5


  -8,00  |  9,00   |  -3,00  |  2,00   |  6,00   |
  7,00   |  -6,00  |  -5,00  |  -9,00  |  6,00   |
  5,00   |  4,00   |  6,00   |  -1,00  |  -9,00  |
  -4,00  |  3,00   |  -8,00  |  -9,00  |  5,00   |
  6,00   |  0,00   |  3,00   |  3,00   |  8,00   |

lower-triangular matrix
Number of rows: 5
Number of columns: 5


  1,00   |  0,00   |  0,00   |  0,00   |  0,00  |
  -0,88  |  1,00   |  0,00   |  0,00   |  0,00  |
  -0,62  |  5,13   |  1,00   |  0,00   |  0,00  |
  0,50   |  -0,80  |  -0,29  |  1,00   |  0,00  |
  -0,75  |  3,60   |  0,65   |  -1,26  |  1,00  |

upper-triangular matrix
Number of rows: 5
Number of columns: 5


  -8,00  |  9,00  |  -3,00  |  2,00   |  6,00    |
  0,00   |  1,88  |  -7,62  |  -7,25  |  11,25   |
  0,00   |  0,00  |  43,27  |  37,47  |  -63,00  |
  0,00   |  0,00  |  0,00   |  -4,89  |  -7,35   |
  0,00   |  0,00  |  0,00   |  0,00   |  3,77    |

A = LU

  -8,00  |  9,00   |  -3,00  |  2,00   |  6,00   |
  7,00   |  -6,00  |  -5,00  |  -9,00  |  6,00   |
  5,00   |  4,00   |  6,00   |  -1,00  |  -9,00  |
  -4,00  |  3,00   |  -8,00  |  -9,00  |  5,00   |
  6,00   |  0,00   |  3,00   |  3,00   |  8,00   |

</code></pre>
<h4 id="lup-decomposition-1">LUP decomposition</h4>
<p>It turns out that a proper permutation in rows (or columns) is sufficient for LU factorization. LU factorization with partial pivoting (LUP) refers often to LU factorization with row permutations only:</p>
<h5>PA = LU</h5>
<p>where L and U are again lower and upper triangular matrices, and P is a permutation matrix, which, when left-multiplied to A, reorders the rows of A. It turns out that all square matrices can be factorized in this form, and the factorization is numerically stable in practice.This makes LUP decomposition a useful technique in practice.</p>
<pre><code class="lang-c#">public class LUPSample
{
    public static void Run()
    {
        // initialize matrix with random values.
        Matrix&lt;double&gt; matrix = BuildMatrix.Random(3, 3, -10, 10);
        
        // display matrix.
        matrix.Pretty();
        
        // LU decomposition.
        matrix.GetLowerUpperPermutation(out var lower,out var upper,out var perm);
        
        // Gets permutation matrix and C = L + U - E.
        matrix.GetLowerUpperPermutation(out var matrixC,out var matrixP);
        
        // display lower-triangular matrix.
        Console.WriteLine(&quot;lower-triangular matrix&quot;);
        lower.Pretty();
        
        // display upper-triangular matrix.
        Console.WriteLine(&quot;upper-triangular matrix&quot;);
        upper.Pretty();
        
        // display permutation matrix.
        Console.WriteLine(&quot;permutation matrix&quot;);
        perm.Pretty();
        
        // display matrix C
        Console.WriteLine(&quot;matrix C = L + U - E&quot;);
        matrixC.Pretty();
    }
}

</code></pre>
<h6 id="output-1">Output</h6>
<pre><code class="lang-ini">Number of rows: 3
Number of columns: 3

  -8,00  |  -6,00  |  -1,00  |
  5,00   |  6,00   |  6,00   |
  -1,00  |  -2,00  |  -5,00  |

lower-triangular matrix
Number of rows: 3
Number of columns: 3

  1,00   |  0,00   |  0,00  |
  -0,62  |  1,00   |  0,00  |
  0,12   |  -1,80  |  1,00  |

upper-triangular matrix
Number of rows: 3
Number of columns: 3

  -8,00  |  -6,00  |  -1,00  |
  0,00   |  -1,25  |  -4,88  |
  0,00   |  0,00   |  -3,40  |

permutation matrix
Number of rows: 3
Number of columns: 3

  1,00  |  0,00  |  0,00  |
  0,00  |  0,00  |  1,00  |
  0,00  |  1,00  |  0,00  |

matrix C = L + U - E
Number of rows: 3
Number of columns: 3


  -8,00  |  -6,00  |  -1,00  |
  5,00   |  6,00   |  6,00   |
  -1,00  |  -0,33  |  -3,00  |
</code></pre>
<h4 id="solving-a-linear-system">Solving a linear system</h4>
<h5 id="kramer-solve">Kramer solve</h5>
<p>Cramer's rule is an explicit formula for the solution of a system of linear equations with as many equations as unknowns,
valid whenever the system has a unique solution. It expresses the solution in terms of the determinants of the (square) coefficient matrix and
of matrices obtained from it by replacing one column by the column vector of right-hand-sides of the equations.</p>
<pre><code class="lang-c#">public sealed class Program
{
    static void Main(string[] args)
    {
        // initialize matrix.
        double[,] arr =
        {
            {5,56,7},
            {3,6,3},
            {5,9,15}
        };


        Matrix&lt;double&gt; matrix = new Matrix&lt;double&gt;(arr);

        double[] right = { 1, 23, 5 };

        double[] res = matrix.KramerSolve(right);
        for(var i = 0; i &lt; res.Length; i++)
        {
            Console.Write($&quot;x{i}: {res[i]}\n&quot;);
        }
    }
}
 
</code></pre>
<h6 id="output-2">Output</h6>
<pre><code class="lang-ini">x0: 12,393939393939394
x1: -0,6637806637806638
x2: -3,3997113997114
</code></pre>
<h4 id="gauss-solve">Gauss solve</h4>
<p>Gaussian elimination, also known as row reduction, is an algorithm in linear algebra for solving a system of linear equations.
It is usually understood as a sequence of operations performed on the corresponding matrix of coefficients.
This method can also be used to find the rank of a matrix, to calculate the determinant of a matrix, and to calculate the inverse of an invertible square matrix.</p>
<pre><code class="lang-c#">using System;
using MatrixDotNet;
using MatrixDotNet.Extensions.Solver;

namespace Samples.Samples
{
    public class GaussSolveSample
    {

        public static void Run()
        {
            // initialize matrix.
            Matrix&lt;double&gt; matrix = new double[,]
            {
                {5, 56, 7},
                {3, 6, 3},
                {5, 9, 15}
            };

            double[] right = { 1, 23, 5 };

            double[] res = matrix.GaussSolve(right);
            for(var i = 0; i &lt; res.Length; i++)
            {
                Console.Write($&quot;x{i}: {res[i]}\n&quot;);
            }
        }
    }
}
</code></pre>
<h6 id="output-3">Output</h6>
<pre><code class="lang-ini">x0: 12,393939393939394
x1: -0,6637806637806638
x2: -3,3997113997114
</code></pre>
<h4 id="conversion-matrix">Conversion Matrix</h4>
<p>Conversion of matrix consist in <code>MatrixDotNet.Extensions.Conversion</code> which contains static class <code>MatrixConverter</code>.</p>
<h5 id="how-change-size-of-matrix">How change size of Matrix?</h5>
<p>In this sample i`ll demonstrate how you can add column or row in any position of matrix and reduce them.</p>
<pre><code class="lang-c#">using System;
using MatrixDotNet;
using MatrixDotNet.Extensions;
using MatrixDotNet.Extensions.Builder;
using MatrixDotNet.Extensions.Conversion;

namespace Sample
{
    public class ConverterSample
    {
        public static void Run()
        {
            // Build matrix.
            Matrix&lt;int&gt; matrix = BuildMatrix.Build(3,3,
                (x, y) =&gt; x + y * y,
                new[] { 43, 23, 54 },
                new[] { 52, 12, 21 });

            Console.WriteLine(&quot;Before conversion:&quot;);
            matrix.Pretty();
            
            // Add row to matrix by index.
            Matrix&lt;int&gt; matrixA = matrix.AddRow(new[] { 1, 2, 3 }, 1);
            Console.WriteLine(&quot;Add row to matrix on second row index:&quot;);
            matrixA.Pretty();
            
            // Add column to matrix by index.
            Matrix&lt;int&gt; matrixB = matrix.AddColumn(new[] { 4, 5, 6 }, 2);
            Console.WriteLine(&quot;Add column to matrix on second column index:&quot;);
            matrixB.Pretty();
            
            // now we will reduce this new column and row.
            Matrix&lt;int&gt; matrixC = matrix.ReduceColumn(2);
            Matrix&lt;int&gt; matrixD = matrix.ReduceRow(1);
            Console.WriteLine(&quot;After reduce:&quot;);
            matrixC.Pretty();
            matrixD.Pretty();

            // Also in MatrixDotNet you can join two matrix with the same size row length.
            Matrix&lt;int&gt; matrixF = matrixA.Concat(matrixA);
            matrixF.Pretty();
        }
    }
}
</code></pre>
<h4 id="output-4">Output</h4>
<pre><code class="lang-ini">Before conversion:

Number of rows: 3
Number of columns: 3

  2747  |  187  |  484  |
  2727  |  167  |  464  |
  2758  |  198  |  495  |

Add row to matrix on second row index:

Number of rows: 4
Number of columns: 3

  2747  |  187  |  484  |
  1     |  2    |  3    |
  2727  |  167  |  464  |
  2758  |  198  |  495  |

Add column to matrix on second column index:

Number of rows: 3
Number of columns: 4

  2747  |  187  |  4  |  484  |
  2727  |  167  |  5  |  464  |
  2758  |  198  |  6  |  495  |

After reduce:

Number of rows: 3
Number of columns: 2

  2747  |  187  |
  2727  |  167  |
  2758  |  198  |


Number of rows: 2
Number of columns: 3

  2747  |  187  |  484  |
  2758  |  198  |  495  |


Number of rows: 4
Number of columns: 6

  2747  |  187  |  484  |  2747  |  187  |  484  |
  1     |  2    |  3    |  1     |  2    |  3    |
  2727  |  167  |  464  |  2727  |  167  |  464  |
  2758  |  198  |  495  |  2758  |  198  |  495  |
</code></pre>
<h5 id="how-to-cast-matrix-to-two-dimensional-array">How to cast matrix to two-dimensional array?</h5>
<pre><code class="lang-c#">using System;
using MatrixDotNet;
using MatrixDotNet.Extensions;
using MatrixDotNet.Extensions.Builder;
using MatrixDotNet.Extensions.Conversion;

namespace Sample {

    public class ConverterSample()
    {
        public static void CastRun()
        {
            // Build matrix.
            Matrix&lt;int&gt; matrixA = BuildMatrix.Build(3,3,
                (x, y) =&gt; x + y * y,
                new[] { 43, 23, 54 },
                new[] { 52, 12, 21 });
            
            // If you want cast Matrix to two-dimensional
            // array use method ToPrimitive.
            int[,] array = matrixA.ToPrimitive();
            
            // Converts two-dimensional array to Matrix.
            var matrixB = array.ToMatrix();
        }
    }
}
</code></pre>
<p>As you can see for convert matrix to two-dimensional array you can easily use method <code>ToPrimitive</code>.</p>
<pre><code class="lang-C#">public class StrassenSample
{
    int[,] matrix = new int[512,512];
    int[,] matrix2 = new int[512,512];

    private Matrix&lt;int&gt; matrix3;
    private Matrix&lt;int&gt; matrix4;

    [GlobalSetup]
    public void Setup()
    {
        Random random = new Random();
        Random random2 = new Random();
        for (int i = 0; i &lt; matrix.GetLength(0); i++)
        {
            for (int j = 0; j &lt; matrix.GetLength(1); j++)
            {
                matrix[i, j] = random.Next(1, 10);
            }
        }
        matrix3 = new Matrix&lt;int&gt;(matrix);

        for (int i = 0; i &lt; matrix2.GetLength(0); i++)
        {
            for (int j = 0; j &lt; matrix2.GetLength(1); j++)
            {
                matrix2[i, j] = random2.Next(1, 10);
            }
        }

        matrix4 = new Matrix&lt;int&gt;(matrix2);
    }

    [Benchmark]
    public Matrix&lt;int&gt; Default()
    {
        return matrix3 * matrix4;
    }

    [Benchmark]
    public Matrix&lt;int&gt; Strassen()
    {
        return MatrixExtension.MultiplyStrassen(matrix3, matrix4);
    }
}
</code></pre>
<pre><code class="lang-ini">
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.14393.3808 (1607/AnniversaryUpdate/Redstone1)
Intel Core i5-8250U CPU 1.60GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores
Frequency=1757816 Hz, Resolution=568.8878 ns, Timer=TSC
  [Host]     : .NET Framework 4.8 (4.8.4180.0), X86 LegacyJIT
  Job-YFITZW : .NET Framework 4.8 (4.8.4180.0), X86 LegacyJIT

IterationCount=5  LaunchCount=1  WarmupCount=5  

</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Gen 0</th>
<th style="text-align: right;">Gen 1</th>
<th style="text-align: right;">Gen 2</th>
<th style="text-align: right;">Allocated</th>
</tr>
</thead>
<tbody>
<tr>
<td>Default</td>
<td style="text-align: right;">69.88 s</td>
<td style="text-align: right;">1.241 s</td>
<td style="text-align: right;">0.322 s</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">-</td>
<td style="text-align: right;">1.01 MB</td>
</tr>
<tr>
<td>Strassen</td>
<td style="text-align: right;">43.23 s</td>
<td style="text-align: right;">0.991 s</td>
<td style="text-align: right;">0.153 s</td>
<td style="text-align: right;">30000.0000</td>
<td style="text-align: right;">5000.0000</td>
<td style="text-align: right;">2000.0000</td>
<td style="text-align: right;">174.32 MB</td>
</tr>
</tbody>
</table>
<p>As you can see algorithm <code>Strassen</code> multiply works significant faster(x1.625) than default multiply matrix on big size <code>M x N</code>.</p>
<h4 id="statistics">Statistics</h4>
<p>In section statistics yo can find any metrics such as minimum, maximum, median. relative frequencies, distribution</p>
<p>Also some algorithms works faster to due bit hacks which eliminate branch prediction.</p>
<p>Lets consider simple benchmark which measure finding minimum of matrix with bitwise operation and custom.</p>
<pre><code class="lang-c#">
public class MatrixBitMinVsDefaultMin
{
    private int N = 256;
    private int[,] matrix;
    private Matrix&lt;int&gt; matrix3;
    private Random random = new Random();
    private int[] arr;

    [GlobalSetup]
    public void Setup()
    {
        matrix = new int[N,N];
        arr = new int[N];
        // init matrix random data
        for (int i = 0; i &lt; N; i++)
        {
            for (int j = 0; j &lt; N; j++)
            {
                matrix[i, j] = random.Next(-255, 255);
            }
        }
        matrix3 = new Matrix&lt;int&gt;(matrix);


    }

    [Benchmark]
    public void DefaultMin()
    { 
        for (int i = 0; i &lt; N; i++)
        {
            arr[i] = matrix3.Min();   
        }
    }
    
    [Benchmark]
    public void BitMin()
    {
        for (int i = 0; i &lt; N; i++)
        {
            arr[i] = matrix3.BitMin();   
        }
    }
}

</code></pre>
<pre><code class="lang-ini">BenchmarkDotNet=v0.12.1, OS=Windows 10.0.14393.3808 (1607/AnniversaryUpdate/Redstone1)
Intel Core i5-8250U CPU 1.60GHz (Kaby Lake R), 1 CPU, 8 logical and 4 physical cores
Frequency=1757816 Hz, Resolution=568.8878 ns, Timer=TSC
  [Host]     : .NET Framework 4.8 (4.8.4180.0), X86 LegacyJIT
  DefaultJob : .NET Framework 4.8 (4.8.4180.0), X86 LegacyJIT
</code></pre>
<table>
<thead>
<tr>
<th>Method</th>
<th style="text-align: right;">Mean</th>
<th style="text-align: right;">Error</th>
<th style="text-align: right;">StdDev</th>
<th style="text-align: right;">Code Size</th>
</tr>
</thead>
<tbody>
<tr>
<td>DefaultMin</td>
<td style="text-align: right;">1,117.2 ms</td>
<td style="text-align: right;">12.93 ms</td>
<td style="text-align: right;">11.46 ms</td>
<td style="text-align: right;">292 B</td>
</tr>
<tr>
<td>BitMin</td>
<td style="text-align: right;">646.5 ms</td>
<td style="text-align: right;">4.16 ms</td>
<td style="text-align: right;">3.25 ms</td>
<td style="text-align: right;">165 B</td>
</tr>
</tbody>
</table>
<p>As you can see BitMin() method works faster(x1.725) than DefaultMin(). Because we eliminate branch prediction.
See more information about Bitwise operations in <a href="https://toor1245.github.io/MatrixDotNet/articles/intro.html">article</a>.</p>
<div class="NOTE">
<h5>Note</h5>
<p>If you didn't find answer for your question on this page, <a href="https://gitter.im/MatrixDotNet/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge">ask it on gitter</a>.</p>
</div>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/toor1245/MatrixDotNet/blob/dev-toor-docs/docs/index.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              <!-- <p><a class="back-to-top" href="#top">Back to top</a><p> -->
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2020 MatrixDotNet
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="styles/docfx.js"></script>
    <script type="text/javascript" src="styles/main.js"></script>
  </body>
</html>
